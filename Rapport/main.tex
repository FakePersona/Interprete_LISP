\documentclass[a4paper,11pt]{article}
\usepackage{a4wide}%

\usepackage{tabularx}

\usepackage{fullpage}%
\usepackage[T1]{fontenc}%
\usepackage[utf8]{inputenc}%
\usepackage[main=francais,english]{babel}%

\usepackage{graphicx}%
\usepackage{xspace}%
\usepackage{float}

\usepackage{url} \urlstyle{sf}%
\DeclareUrlCommand\email{\urlstyle{sf}}%

\usepackage{mathpazo}%
\let\bfseriesaux=\bfseries%
\renewcommand{\bfseries}{\sffamily\bfseriesaux}

\newenvironment{keywords}%
{\description\item[Mots-clés.]}%
{\enddescription}


\newenvironment{remarque}%
{\description\item[Remarque.]\sl}%
{\enddescription}

\font\manual=manfnt
\newcommand{\dbend}{{\manual\char127}}

\newenvironment{attention}%
{\description\item[\dbend]\sl}%
{\enddescription}

\usepackage{listings}%

\lstset{%
  basicstyle=\sffamily,%
  columns=fullflexible,%
  language=c,%
  frame=lb,%
  frameround=fftf,%
}%

\lstMakeShortInline{|}

\parskip=0.3
\baselineskip

\sloppy

%opening
\title{Interprète Lisp en C++}
\author{Antonin Garret \and Rémy Sun}
\date{21 avril 2016}


\begin{document}

\maketitle

\section{Objectif}

L'objectif que nous nous sommes fixés pour ce projet était de construire un
interprète lisp gérant les liaisons à la manière de Scheme. Plus
particulièrement, nous étions intéressés par la gestion de liste chaînées de
frames, et par la façon dont on pouvait représenter ces frames pour permettre la
création d'un tel interpréteur.

Au delà des problèmes de définitions circulaires posés, le grand défi a été de
gérer correctement la création des copies (implicites dès qu'on passe en
argument de fonction) et la bonne détection des clôtures.

Nous nous somme fixés les objectifs intermédiaires suivant:
\begin{itemize}
\item Compléter le squelette fourni pour obtenir un interprète dynamique, ce qui
  constitue une première étape facilement vérifiable.
\item Passer de la gestion d'environnement proposée à une gestion par listes
  chaînées, ce qui permettrait eu passage de commencer à réfléchir à la façon de
  gérer les frames.
\item Créer un premier interprète à liaison statique identique à celui vu en TD.
\item Implémenter une gestion des clôtures dans cet interprète. Le but original
  était d'explorer la possibilité de stocker tout l'environement courant (donc
  en le dédoublant), possibilité non développée en TD. Après constatation des
  nombreux problèmes que cela pose (mais aussi de ce qu'il est possible de
  faire) nous avons créé une autre clôture utilisant des pointeurs
  d’environnement.
\item Implémenter la gestion de frames, adapter la clôture Scheme.
\end{itemize}


\section{Travail réalisé}

\subsection{Interprète dynamique}

Dans un premier temps, nous avons implémenté, à partir du code fourni, un interprète 
qui possède les principale fonctions Lisp, avec une gestion dynamique de l'environnement.

\subsubsection{Toplevel et environnement}

  Nous avons encapsulé la gestion des entrées dans un \texttt{toplevel}, 
 appelé par la fonction \texttt{main}. Ce toplevel gère la directive setq, qui
 permet de modifier l'environnement. 
 Elle fait appel à une fonction \texttt{add\_new\_binding} que nous avons
 implémenté, qui permet de créer un nouvel objet
  \texttt{Binding} (qui comporte deux éléments : un
 symbole et la valeur qui lui est associée) que l'on ajoute à l'environnement courant. 
 Dans le code original, les environnement sont traités comme des vecteurs de pointeurs 
 vers des
 \texttt{Binding}.  Cette version dynamique de l'interprète ajoute un \texttt{Binding} 
 à chaque fois que \texttt{setq} est appelée, sans vérifier si un \texttt{Binding} 
 correspondant au symbole utilisé existe déjà. Comme la fonction de recherche dans 
 l'environnement renvoie le premier \texttt{Binding} trouvé, cette nouvelle liaison
 masque de façon effective celles déjà enregistrées.
 
 D'autre part nous avons aussi ré-encapsulé la gestion des entrées de l'utilisateur 
 dans le \texttt{toplevel} dans une classe \texttt{read} qui gère les appels au parseur.
 
 \subsubsection{Subroutines}
 
  Dans le code fourni, quelques subroutines étaient traitées dans la fonction 
  \texttt{eval} de l'interprète. Nous avons encapsulé les subroutines pour qu'elles soient 
  traitées de manière séparée, afin de pouvoir facilement en ajouter de nouvelles. 
  Les opérations de bases sur les nombres, ainsi que les fonctions \texttt{car}, 
  \texttt{cdr}, \texttt{cons}, \texttt{concat}, \texttt{newline} et \texttt{read} 
  ont été implémentées.
  
  Pour la subroutine =, nous nous sommes inspirés de l’interprète Caml vu en TD, en 
  comparant le type de chaque objet, avant de comparer leur valeur si le type 
  correspond. Nous avons aussi implémenté la gestion des booléens dans la classe 
  \texttt{Object}, afin de clarifier et de simplifier leur utilisation, en 
  particulier dans cette fonction.
  
  Nous avons d'autre part pu remarquer l'utilité de l'encapsulation déjà effectuée, 
  car il nous a suffit de réutiliser les fonctions de la classe \texttt{read} 
  pour implémenter la subroutine \texttt{read}.
  
 \subsubsection{Eval}
 
 La principale modification apportée à la classe \texttt{eval} fournie est 
l'utilisation de l'encapsulation précédemment mentionnée pour mieux compartimenter 
les différentes parties de l'évaluation. Nous avons utilisé la programmation 
par exception afin de s'assurer que chacune des ces parties se déroulent 
correctement. Par exemple, lors de l'évaluation d'un symbole, on fait appel 
à une fonction qui parcours l'environnement courant afin de trouver une liaison 
correspondante, et renvoie une exception en cas d'échec. Cela nous permet de 
repérer lorsque l'utilisateur cherche à évaluer un symbole qui n'est pas attribué.

Nous avons aussi aussi implémenté un dispositif de trace via la commande 
\texttt{debug} et d'impression de l'environnement via \texttt{printenv}, 
pour permettre à l'utilisateur de suivre l'évolution de l'environnement courant.

\subsection{Environnement par listes chaînées}

Si l'implémentation des environnement comme vecteurs 
de pointeurs vers des \texttt{Binding} a le mérite de marcher, elle n'en est
pas moins problématique au sens où, pour copier un environnement, il est
nécessaire de copier l'intégralité de la liste des pointeurs, ce qui présente un
coût linéaire en la taille de l'environement considéré!

La première idée pour remédier à cela est de faire de l'environement un unique
pointeur vers le vecteur de pointeurs. Cela ne fait cependant que déplacer le
problème dans le cas où il faut copier aussi ce vecteur.

Aussi, il semble judicieux de transformer l'environement en liste chaînée:
chaque bloc de la liste contient un unique \texttt{Binding} et un pointeur vers
le prochain bloc (éventuellement NULL). Il faut noter que nous ne perdons rien
en efficacité, puisqu'il fallait de toute façon parcourir tout le vecteur de
pointeurs pour trouver le \texttt{Binding} correspondant à une chaîne donnée.

\subsubsection{Blocs d’environnement}

Nous avons ainsi défini une structure \texttt{EnvBlock} qui constitue un maillon
de la liste chaînée. Puisque ces maillons sont eux mêmes repérés par leur
pointeur, et pour une raison que nous verrons plus tard, il n'est pas nécessaire
d'utiliser des pointeurs de \texttt{Binding}.

\subsubsection{Environnement = Bloc?}

La principale question qui s'est posée est la suivante :considère-t-on qu'un
environnement est un bloc (le bloc de \og tête\fg) ou considère-t-on que
l'environement est quelque chose d'autre que la somme individuelle de ses
parties?

Nous avons privilégié la deuxième approche. En effet, elle permet de gérer plus
proprement l'allocation dynamique en mémoire de blocs d’environnement. De plus,
cela rendait beaucoup plus facile la destruction des blocs d’environnements
alloués en mémoire ainsi que la création de copies indépendantes (créant aussi
de nouveaux blocs). Cette gestion des copies s'est révélée par la suite sans
grand intérêt, mais le code utilisé demeure dans le dossier \texttt{Copie}

C'est cette macro-structure qui s'occupe de la gestion des ajouts et
consultations de \texttt{Binding} :c'est elle qui fournit l'interface publique
de l'environement.

\begin{attention}
  Une difficulté rencontrée avec l'utilisation d'instances de \texttt{Binding}
  au lieu de pointeurs dans les blocs d’environnement a été la création
  implicites de copies que nous avons du tracer à l'aide d'impressions de
  pointeurs. L'utilisation d'un setter à permis de remédier à ces problèmes.
\end{attention}

\subsection{Première liaison statique}

\subsection{Première clôture}

\subsection{Passage en frames}

\subsection{Clotures scheme}

\section{Vérification}

\section{Contribution}




\begin{itemize}
\item http://stackoverflow.com
\item https://openclassrooms.com
\item http://www.cs.rpi.edu
\end{itemize}


\end{document}
